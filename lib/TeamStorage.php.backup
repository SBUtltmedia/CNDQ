<?php
/**
 * TeamStorage - Manages all file operations for a single team.
 * Refactored to adhere to No-M (Filesystem-as-State) philosophy.
 */

require_once __DIR__ . '/NoM/Aggregator.php';
require_once __DIR__ . '/TeamNameGenerator.php';

class TeamStorage {
    private $teamEmail;
    private $teamDir;
    private $safeEmail;
    private $cacheFile;
    private $teamName;

    /**
     * Initialize storage for a specific team
     * @param string $email Team's email address
     */
    public function __construct($email) {
        $this->teamEmail = $email;
        $this->safeEmail = $this->sanitizeEmail($email);
        $this->teamDir = __DIR__ . '/../data/teams/' . $this->safeEmail;
        $this->cacheFile = $this->teamDir . '/cached_state.json';
        $this->ensureDirectoryStructure();
    }

    /**
     * Get the team name (with caching)
     */
    public function getTeamName() {
        if ($this->teamName) return $this->teamName;
        $state = $this->getState();
        $this->teamName = $state['profile']['teamName'] ?? $this->teamEmail;
        return $this->teamName;
    }

    /**
     * Sanitize email for safe filesystem usage
     */
    public static function sanitizeEmail($email) {
        return preg_replace('/[^a-zA-Z0-9_\-@.]/', '_', $email);
    }

    /**
     * Create team directory and emit initial event if new
     */
    private function ensureDirectoryStructure() {
        if (!is_dir($this->teamDir)) {
            if (!mkdir($this->teamDir, 0755, true)) {
                throw new \Exception("Failed to create team directory: {$this->teamDir}");
            }
            
            $this->teamName = TeamNameGenerator::generate($this->teamEmail);
            
            $timestamp = microtime(true);
            $filename = "event_" . sprintf('%0.6f', $timestamp) . "_init.json";
            
            $event = [
                'type' => 'init',
                'payload' => [
                    'profile' => [
                        'email' => $this->teamEmail,
                        'teamName' => $this->teamName,
                        'createdAt' => time(),
                        'currentFunds' => 0,
                        'startingFunds' => 0
                    ],
                    'inventory' => [
                        'C' => round(rand(500, 2000), 4),
                        'N' => round(rand(500, 2000), 4),
                        'D' => round(rand(500, 2000), 4),
                        'Q' => round(rand(500, 2000), 4)
                    ],
                    'shadowPrices' => [
                        'C' => 0, 'N' => 0, 'D' => 0, 'Q' => 0
                    ]
                ],
                'timestamp' => $timestamp,
                'teamId' => $this->teamEmail,
                'teamName' => $this->teamName
            ];

            file_put_contents($this->teamDir . '/' . $filename, json_encode($event, JSON_PRETTY_PRINT));

            $this->runAutomaticFirstProduction();
        }
    }

    /**
     * Emit an event (Atomic Write)
     */
    public function emitEvent(string $type, array $payload) {
        // Micro-sleep to ensure unique timestamp and allow FS to breathe
        usleep(50000); 
        clearstatcache(true);
        $timestamp = microtime(true);
        $event = [
            'type' => $type,
            'payload' => $payload,
            'timestamp' => $timestamp,
            'teamId' => $this->teamEmail,
            'teamName' => $this->teamName ?? ($type === 'init' ? $payload['profile']['teamName'] : $this->getTeamName())
        ];

        $jsonData = json_encode($event, JSON_PRETTY_PRINT);
        // Use high-precision timestamp to ensure order and uniqueness
        $filename = "event_" . sprintf('%0.6f', $timestamp) . "_" . $type . ".json";
        
        $tmp = tempnam($this->teamDir, 'tmp_');
        if (file_put_contents($tmp, $jsonData) === false) {
            throw new Exception("Failed to write temporary event file");
        }
        
        // --- NEW: Shared Event Log for fast global querying ---
        $sharedTypes = ['add_offer', 'remove_offer', 'update_offer', 'add_buy_order', 'remove_buy_order', 'update_buy_order', 'add_ad', 'remove_ad'];
        if (in_array($type, $sharedTypes)) {
            $sharedDir = __DIR__ . '/../data/marketplace/events';
            if (!is_dir($sharedDir)) {
                mkdir($sharedDir, 0755, true);
            }
            
            // Explicitly inject teamName into payload for the shared log
            $event['payload']['teamName'] = $this->getTeamName();
            $sharedJsonData = json_encode($event, JSON_PRETTY_PRINT);
            file_put_contents($sharedDir . '/' . $filename, $sharedJsonData);
            
            // On Windows, a small delay helps ensure the file is visible to other processes
            usleep(100000); // 100ms
        }

        if (!@rename($tmp, $this->teamDir . '/' . $filename)) {
            // Fallback for Windows file locks
            if (@copy($tmp, $this->teamDir . '/' . $filename)) {
                @unlink($tmp);
            } else {
                $err = error_get_last();
                error_log("TeamStorage: Critical write failure for $filename: " . ($err['message'] ?? 'Unknown error'));
                @unlink($tmp);
            }
        }

        // Invalidate cache by deleting it or updating its mtime to be old
        if (file_exists($this->cacheFile)) {
            @unlink($this->cacheFile);
        }
    }

    /**
     * Get the current state (Aggregated and Cached)
     */
    public function getState(): array {
        clearstatcache(true);
        // State Caching: Compare mtime of newest event with mtime of cached_state.json
        $cacheMtime = file_exists($this->cacheFile) ? filemtime($this->cacheFile) : 0;
        
        // Find newest event file
        $events = glob($this->teamDir . '/event_*.json');
        $newestEventMtime = 0;
        if (!empty($events)) {
            // We only need the latest one, and since they are named with timestamps,
            // the last one in the sorted list is usually the newest.
            sort($events);
            $newestEventMtime = filemtime(end($events));
        }

        if ($cacheMtime > $newestEventMtime && $cacheMtime > 0) {
            $content = file_get_contents($this->cacheFile);
            $cached = json_decode($content, true);
            if (is_array($cached) && isset($cached['profile'])) {
                // error_log("TeamStorage [{$this->teamEmail}]: Using cached state.");
                return $cached;
            }
        }

        // Aggregate state from legacy files and events
        $state = \NoM\Aggregator::aggregate($this->teamDir);
        
        // Save to cache
        $tmp = tempnam($this->teamDir, 'tmp_cache_');
        file_put_contents($tmp, json_encode($state, JSON_PRETTY_PRINT));
        
        // Use @ to suppress permission denied warnings on Windows if file is locked
        if (!@rename($tmp, $this->cacheFile)) {
            @unlink($tmp);
        }

        // Check if we should create a snapshot (e.g. every 50 events)
        $eventsSinceSnapshot = $state['eventsProcessed'] - ($state['snapshotEvents'] ?? 0);
        if ($eventsSinceSnapshot >= 50) {
            $this->createSnapshot($state);
        }

        return $state;
    }

    /**
     * Create a baseline snapshot of the current state
     */
    private function createSnapshot(array $state) {
        $state['snapshotEvents'] = $state['eventsProcessed'];
        $state['snapshotAt'] = time();
        
        $snapshotFile = $this->teamDir . '/snapshot.json';
        $tmp = tempnam($this->teamDir, 'tmp_snap_');
        file_put_contents($tmp, json_encode($state, JSON_PRETTY_PRINT));
        if (!@rename($tmp, $snapshotFile)) {
            @unlink($tmp);
        }
        
        // Optional: Clean up old event files that are now in the snapshot
        // (Be careful with this in a real audit log system, maybe move to 'archive/' instead)
    }

    /**
     * Automatically run first production for new teams
     * Processes all available chemicals using the LP algorithm
     */
    private function runAutomaticFirstProduction() {
        require_once __DIR__ . '/LPSolver.php';

        $inventory = $this->getInventory();
        $solver = new LPSolver();
        $result = $solver->solve($inventory);

        $deicerGallons = $result['deicer'];
        $solventGallons = $result['solvent'];
        $revenue = $result['maxProfit'];

        $consumed = [
            'C' => $deicerGallons * LPSolver::DEICER_C,
            'N' => ($deicerGallons * LPSolver::DEICER_N) + ($solventGallons * LPSolver::SOLVENT_N),
            'D' => ($deicerGallons * LPSolver::DEICER_D) + ($solventGallons * LPSolver::SOLVENT_D),
            'Q' => $solventGallons * LPSolver::SOLVENT_Q
        ];

        foreach ($consumed as $chem => $amount) {
            $this->adjustChemical($chem, -$amount);
        }

        // The first production establishes the baseline starting funds
        $this->setFunds($revenue, true);

        $this->addProduction([
            'type' => 'automatic_initial',
            'deicer' => $deicerGallons,
            'solvent' => $solventGallons,
            'revenue' => $revenue,
            'chemicalsConsumed' => $consumed,
            'note' => 'Initial production (100% capacity) to set starting funds'
        ]);
    }

    // ==================== Profile Methods ====================

    public function getProfile() { return $this->getState()['profile']; }

    public function updateProfile($callback) {
        $state = $this->getState();
        $newProfile = $callback($state['profile']);
        $this->emitEvent('update_profile', $newProfile);
        return $newProfile;
    }

    public function setTeamName($name) {
        $this->updateProfile(function($p) use ($name) {
            $p['teamName'] = $name;
            return $p;
        });
    }

    public function updateFunds($amount) {
        $this->emitEvent('adjust_funds', ['amount' => $amount]);
    }

    public function setFunds($amount, $isStarting = false) {
        $this->emitEvent('set_funds', ['amount' => $amount, 'is_starting' => $isStarting]);
    }

    // ==================== Inventory Methods ====================

    public function getInventory() { return $this->getState()['inventory']; }

    public function updateInventory($callback) {
        $state = $this->getState();
        $newInventory = $callback($state['inventory']);
        $this->emitEvent('init', ['inventory' => $newInventory]);
        return $newInventory;
    }

    public function adjustChemical($chemical, $amount) {
        $this->emitEvent('adjust_chemical', ['chemical' => $chemical, 'amount' => $amount]);
    }

    public function resetShadowCalcCounter() {
        $this->emitEvent('update_shadow_prices', $this->getShadowPrices());
    }

    // ==================== Shadow Prices Methods ====================

    public function getShadowPrices() { return $this->getState()['shadowPrices']; }

    public function updateShadowPrices($prices) {
        $this->emitEvent('update_shadow_prices', $prices);
    }

    // ==================== Offers Methods ====================

    public function getOffersMade() { return ['offers' => $this->getState()['offers']]; }

    public function addOffer($data) {
        $data['id'] = 'offer_' . time() . '_' . bin2hex(random_bytes(4));
        $data['sellerId'] = $this->teamEmail;
        $data['createdAt'] = time();
        $data['status'] = 'active';
        $this->emitEvent('add_offer', $data);
        return ['offers' => $this->getOffersMade()['offers']];
    }

    public function updateOffer($id, $updates) {
        $this->emitEvent('update_offer', ['id' => $id, 'updates' => $updates]);
    }

    public function removeOffer($id) {
        $this->emitEvent('remove_offer', ['id' => $id]);
    }

    // ==================== Buy Orders Methods ====================

    public function getBuyOrders() { return ['interests' => $this->getState()['buyOrders']]; }

    public function addBuyOrder($data) {
        // --- Garbage Collection: Remove existing active orders for this chemical ---
        $existingOrders = $this->getBuyOrders()['interests'];
        foreach ($existingOrders as $existingOrder) {
            if (($existingOrder['chemical'] ?? '') === ($data['chemical'] ?? '')) {
                $this->removeBuyOrder($existingOrder['id']);
            }
        }

        $data['id'] = 'buy_' . time() . '_' . bin2hex(random_bytes(4));
        $data['buyerId'] = $this->teamEmail;
        $data['createdAt'] = time();
        $data['status'] = 'active';
        $this->emitEvent('add_buy_order', $data);
        return ['interests' => $this->getBuyOrders()['interests']];
    }

    public function updateBuyOrder($id, $updates) {
        $this->emitEvent('update_buy_order', ['id' => $id, 'updates' => $updates]);
    }

    public function removeBuyOrder($id) {
        $this->emitEvent('remove_buy_order', ['id' => $id]);
    }

    // ==================== Transactions Methods ====================

    public function getTransactions() { return ['transactions' => $this->getState()['transactions']]; }

    public function addTransaction($data) {
        $data['id'] = 'txn_' . time() . '_' . bin2hex(random_bytes(4));
        $this->emitEvent('add_transaction', $data);
    }

    // ==================== Notifications Methods ====================

    public function getNotifications() { return ['notifications' => $this->getState()['notifications']]; }

    public function addNotification($data) {
        $data['id'] = 'notif_' . time() . '_' . bin2hex(random_bytes(4));
        $this->emitEvent('add_notification', $data);
        return $data;
    }

    public function markNotificationsRead($ids = null) {
        $this->emitEvent('mark_notifications_read', ['ids' => $ids]);
    }

    // ==================== Advertisement Methods ====================

    public function getAds() { return $this->getState()['ads']; }

    public function addAd($chemical, $type) {
        // --- Garbage Collection: Remove existing active ads for this chemical/type ---
        $existingAds = $this->getAds();
        foreach ($existingAds as $existingAd) {
            if ($existingAd['chemical'] === $chemical && $existingAd['type'] === $type) {
                $this->removeAd($existingAd['id']);
            }
        }

        $ad = [
            'id' => 'ad_' . time() . '_' . bin2hex(random_bytes(4)),
            'teamId' => $this->teamEmail,
            'chemical' => $chemical,
            'type' => $type,
            'status' => 'active',
            'createdAt' => time()
        ];
        $this->emitEvent('add_ad', $ad);
        return ['ads' => $this->getAds()];
    }

    public function removeAd($adId) {
        $this->emitEvent('remove_ad', ['id' => $adId]);
    }

    // ==================== Production Methods ====================

    public function addProduction($data) { $this->emitEvent('add_production', $data); }
    public function getProductionHistory() { return $this->getState()['productions']; }

    // ==================== Settings Methods ====================

    public function getSettings() { return $this->getState()['profile']['settings'] ?? []; }

    public function updateSettings($settings) {
        $this->updateProfile(function($p) use ($settings) {
            $p['settings'] = array_merge($p['settings'] ?? [], $settings);
            return $p;
        });
    }

    // ==================== Utility Methods ====================

    public function getTeamEmail() { return $this->teamEmail; }
    public function getTeamDirectory() { return $this->teamDir; }
    public function getFullState() { return $this->getState(); }
}