/**
 * Dual Playability Test - UI vs API Comparison with ROI-Based Pass Criteria
 *
 * Runs both UI and API tests and compares their results to ensure:
 * 1. UI triggers the correct API calls
 * 2. API endpoints work correctly without UI
 * 3. Both achieve the same game state
 * 4. Game produces measurable economic activity (ROI-based validation)
 *
 * Time-Freeze Awareness:
 * The game uses a "freeze" mechanism where time only advances when clients are active.
 * When no clients poll the server (gap > 10s since lastTick), the game timer pauses.
 * This prevents the game from expiring while tests are switching between players.
 * See SessionManager.php:tick() for implementation details.
 *
 * Pass Criteria (ROI-Based):
 * - At least 1 team must achieve positive ROI
 * - Average ROI must be > -50%
 * - At least 3 trades must execute successfully
 * - Maximum 2 errors allowed
 *
 * Usage:
 *   node tests/dual-playability-test.js
 *   node tests/dual-playability-test.js --headless
 *   node tests/dual-playability-test.js --ui-only
 *   node tests/dual-playability-test.js --api-only
 *   node tests/dual-playability-test.js --verbose
 */

const UIPlayabilityTest = require('./ui-playability-test');
const APIPlayabilityTest = require('./api-playability-test');

const CONFIG = {
    baseUrl: 'http://cndq.test/CNDQ/',
    adminUser: 'admin@stonybrook.edu',
    testUsers: [
        'test_mail1@stonybrook.edu',
        'test_mail2@stonybrook.edu',
        'test_mail3@stonybrook.edu'
    ],
    targetSessions: 2, // Increased to check multi-round health
    headless: process.argv.includes('--headless'),
    verbose: process.argv.includes('--verbose') || process.argv.includes('-v'),
    keepOpen: false, // Never keep open in dual mode

    // ROI-based pass criteria
    minPositiveRoiTeams: 1,        // At least 1 team should have positive ROI
    minAverageRoi: -50,            // Average ROI should be > -50% (allows some losses)
    minTotalTrades: 3,             // At least 3 trades should execute
    maxAcceptableErrors: 2          // Allow up to 2 errors before failing
};

class DualPlayabilityTest {
    constructor(config) {
        this.config = config;
        this.uiResults = null;
        this.apiResults = null;
    }

    async run() {
        console.log('üîÄ DUAL PLAYABILITY TEST - UI vs API');
        console.log('='.repeat(80));
        console.log('This test runs both UI and API tests and compares results.');
        console.log('='.repeat(80));
        console.log('');

        const runUiOnly = process.argv.includes('--ui-only');
        const runApiOnly = process.argv.includes('--api-only');

        try {
            // Run UI test
            if (!runApiOnly) {
                console.log('\n' + '‚ñà'.repeat(80));
                console.log('‚ñà' + ' '.repeat(78) + '‚ñà');
                console.log('‚ñà' + '  PART 1: UI-BASED TEST'.padEnd(78) + '‚ñà');
                console.log('‚ñà' + ' '.repeat(78) + '‚ñà');
                console.log('‚ñà'.repeat(80));
                console.log('');

                const uiTest = new UIPlayabilityTest(this.config);
                await uiTest.run().catch(err => {
                    console.error('UI test failed:', err.message);
                });

                this.uiResults = {
                    uiActions: uiTest.results.uiActions,
                    apiCallsCaptured: uiTest.results.apiCallsCaptured,
                    errors: uiTest.results.errors,
                    warnings: uiTest.results.warnings,
                    apiCallLog: uiTest.apiCallLog
                };

                // Wait between tests to let server settle
                // Note: Game has time-freeze mechanism - when no clients active, timer doesn't advance
                if (!runUiOnly) {
                    console.log('\n‚è∏Ô∏è  Waiting 10 seconds before API test (time-freeze aware)...\n');
                    await new Promise(resolve => setTimeout(resolve, 10000));
                }
            }

            // Run API test
            if (!runUiOnly) {
                console.log('\n' + '‚ñà'.repeat(80));
                console.log('‚ñà' + ' '.repeat(78) + '‚ñà');
                console.log('‚ñà' + '  PART 2: API-BASED TEST'.padEnd(78) + '‚ñà');
                console.log('‚ñà' + ' '.repeat(78) + '‚ñà');
                console.log('‚ñà'.repeat(80));
                console.log('');

                const apiTest = new APIPlayabilityTest(this.config);
                await apiTest.run().catch(err => {
                    console.error('API test failed:', err.message);
                });

                this.apiResults = {
                    apiCalls: apiTest.results.apiCalls,
                    successful: apiTest.results.successful,
                    failed: apiTest.results.failed,
                    errors: apiTest.results.errors,
                    warnings: apiTest.results.warnings,
                    apiCallLog: apiTest.apiCallLog
                };
            }

            // Compare results
            if (!runUiOnly && !runApiOnly) {
                this.compareResults();
            }

        } catch (error) {
            console.error('\n‚ùå Dual test failed:', error.message);
            if (this.config.verbose) {
                console.error(error.stack);
            }
            process.exit(1);
        }
    }

    /**
     * Validate ROI-based pass criteria
     */
    validateRoiCriteria(standings, totalTrades) {
        const validations = {
            passed: true,
            failures: [],
            warnings: []
        };

        if (!standings || standings.length === 0) {
            validations.passed = false;
            validations.failures.push('No standings data available');
            return validations;
        }

        // 1. Check minimum positive ROI teams
        const positiveRoiTeams = standings.filter(t => (t.roi || 0) > 0);
        if (positiveRoiTeams.length < this.config.minPositiveRoiTeams) {
            validations.passed = false;
            validations.failures.push(
                `Only ${positiveRoiTeams.length} team(s) with positive ROI (minimum: ${this.config.minPositiveRoiTeams})`
            );
        }

        // 2. Check average ROI
        const avgRoi = standings.reduce((sum, t) => sum + (t.roi || 0), 0) / standings.length;
        if (avgRoi < this.config.minAverageRoi) {
            validations.passed = false;
            validations.failures.push(
                `Average ROI ${avgRoi.toFixed(1)}% is below minimum ${this.config.minAverageRoi}%`
            );
        }

        // 3. Check total trades
        if (totalTrades < this.config.minTotalTrades) {
            validations.passed = false;
            validations.failures.push(
                `Only ${totalTrades} trade(s) executed (minimum: ${this.config.minTotalTrades})`
            );
        }

        // 4. Check for errors
        const totalErrors = this.uiResults.errors.length + this.apiResults.errors.length;
        if (totalErrors > this.config.maxAcceptableErrors) {
            validations.passed = false;
            validations.failures.push(
                `${totalErrors} error(s) occurred (maximum acceptable: ${this.config.maxAcceptableErrors})`
            );
        }

        // Warnings (non-critical)
        if (positiveRoiTeams.length > 0 && positiveRoiTeams.length < standings.length / 2) {
            validations.warnings.push(
                `Less than half of teams (${positiveRoiTeams.length}/${standings.length}) achieved positive ROI`
            );
        }

        if (avgRoi > 0 && avgRoi < 5) {
            validations.warnings.push(
                `Average ROI is positive but low (${avgRoi.toFixed(1)}%) - market may be inefficient`
            );
        }

        return validations;
    }

    compareResults() {
        console.log('\n' + '‚ñà'.repeat(80));
        console.log('‚ñà' + ' '.repeat(78) + '‚ñà');
        console.log('‚ñà' + '  COMPARISON REPORT'.padEnd(78) + '‚ñà');
        console.log('‚ñà' + ' '.repeat(78) + '‚ñà');
        console.log('‚ñà'.repeat(80));
        console.log('');

        // Basic stats comparison
        console.log('üìä STATISTICS COMPARISON:');
        console.log('-'.repeat(80));
        console.log(`UI Actions Performed:        ${this.uiResults.uiActions}`);
        console.log(`UI - API Calls Captured:     ${this.uiResults.apiCallsCaptured}`);
        console.log(`API - Direct API Calls:      ${this.apiResults.apiCalls}`);
        console.log(`API - Successful Calls:      ${this.apiResults.successful} (${Math.round(this.apiResults.successful / (this.apiResults.apiCalls || 1) * 100)}%)`);
        console.log(`API - Failed Calls:          ${this.apiResults.failed}`);
        console.log('-'.repeat(80));

        // Market Activity (from API test as it has more detailed results)
        if (this.apiResults && this.apiResults.apiCallLog) {
            const leaderboardCall = this.apiResults.apiCallLog.find(c => c.endpoint === '/api/leaderboard/standings');
            if (leaderboardCall && leaderboardCall.response && leaderboardCall.response.data) {
                const standings = leaderboardCall.response.data.standings || [];
                const improved = standings.filter(t => (t.roi || 0) > 0).length;
                const totalTrades = this.apiResults.apiCallLog.filter(c => c.endpoint === '/api/negotiations/accept' && c.response.ok).length;

                console.log('\nüìà MARKET ACTIVITY SUMMARY:');
                console.log('-'.repeat(80));
                console.log(`Total Teams:                 ${standings.length}`);
                console.log(`Teams with Positive ROI:     ${improved} (${Math.round(improved / (standings.length || 1) * 100)}%)`);
                console.log(`Total Trades Executed:       ${totalTrades}`);
                
                if (standings.length > 0) {
                    console.log('\nFinal Standings (Top 5):');
                    standings.slice(0, 5).forEach((team, i) => {
                        console.log(`   ${i + 1}. ${team.teamName.padEnd(20)} ROI: ${team.roi?.toFixed(1) || '0.0'}%`);
                    });
                }
                console.log('-'.repeat(80));
            }
        }

        // Error comparison
        console.log('\nüö® ERROR COMPARISON:');
        console.log('-'.repeat(80));
        console.log(`UI Test Errors:   ${this.uiResults.errors.length}`);
        console.log(`API Test Errors:  ${this.apiResults.errors.length}`);

        if (this.uiResults.errors.length > 0 || this.apiResults.errors.length > 0) {
            if (this.uiResults.errors.length > 0) {
                console.log('\nUI Errors:');
                this.uiResults.errors.forEach((err, i) => {
                    console.log(`   ${i + 1}. ${err.user || 'Unknown'}: ${err.error}`);
                });
            }

            if (this.apiResults.errors.length > 0) {
                console.log('\nAPI Errors:');
                this.apiResults.errors.forEach((err, i) => {
                    console.log(`   ${i + 1}. ${err.user || 'Unknown'}: ${err.error}`);
                });
            }
        } else {
            console.log('‚úÖ Both tests completed without errors!');
        }

        console.log('-'.repeat(80));

        // API endpoint coverage comparison
        console.log('\nüì° API ENDPOINT COVERAGE:');
        console.log('-'.repeat(80));

        // Build endpoint lists
        const uiEndpoints = new Set();
        this.uiResults.apiCallLog.forEach(call => {
            const endpoint = call.url.split('?')[0];
            uiEndpoints.add(endpoint);
        });

        const apiEndpoints = new Set();
        this.apiResults.apiCallLog.forEach(call => {
            apiEndpoints.add(call.endpoint);
        });

        console.log(`UI touched ${uiEndpoints.size} unique endpoints`);
        console.log(`API tested ${apiEndpoints.size} unique endpoints`);

        // Find endpoints only in API test (not triggered by UI)
        const apiOnlyEndpoints = [...apiEndpoints].filter(ep => {
            return ![...uiEndpoints].some(uiEp => uiEp.includes(ep.split('?')[0]));
        });

        if (apiOnlyEndpoints.length > 0) {
            console.log('\n‚ö†Ô∏è  Endpoints tested by API but not triggered by UI:');
            apiOnlyEndpoints.forEach(ep => {
                console.log(`   - ${ep}`);
            });
            console.log('\n   üí° Consider adding UI elements to trigger these endpoints.');
        }

        // Find common endpoints
        const commonEndpoints = [...apiEndpoints].filter(ep => {
            return [...uiEndpoints].some(uiEp => uiEp.includes(ep.split('?')[0]));
        });

        if (commonEndpoints.length > 0) {
            console.log(`\n‚úÖ ${commonEndpoints.length} endpoints tested by both UI and API`);
        }

        console.log('-'.repeat(80));

        // Call frequency comparison for common endpoints
        console.log('\nüî¢ API CALL FREQUENCY (Common Endpoints):');
        console.log('-'.repeat(80));

        const uiFreq = {};
        this.uiResults.apiCallLog.forEach(call => {
            const endpoint = call.url.split('?')[0];
            uiFreq[endpoint] = (uiFreq[endpoint] || 0) + 1;
        });

        const apiFreq = {};
        this.apiResults.apiCallLog.forEach(call => {
            const endpoint = call.endpoint.split('?')[0];
            apiFreq[endpoint] = (apiFreq[endpoint] || 0) + 1;
        });

        // Compare common endpoints
        commonEndpoints.forEach(ep => {
            const uiCount = uiFreq[ep] || 0;
            const apiCount = apiFreq[ep] || 0;
            const diff = Math.abs(uiCount - apiCount);
            const diffPercent = apiCount > 0 ? Math.round((diff / apiCount) * 100) : 0;

            if (diffPercent > 50) {
                console.log(`   ‚ö†Ô∏è  ${ep}`);
                console.log(`       UI: ${uiCount}x, API: ${apiCount}x (${diffPercent}% difference)`);
            } else {
                console.log(`   ‚úÖ ${ep}: UI ${uiCount}x, API ${apiCount}x`);
            }
        });

        console.log('-'.repeat(80));

        // ROI-based validation
        console.log('\nüí∞ ROI-BASED VALIDATION:');
        console.log('='.repeat(80));

        let standings = [];
        let totalTrades = 0;

        // Extract standings and trades from API test results
        if (this.apiResults && this.apiResults.apiCallLog) {
            const leaderboardCall = this.apiResults.apiCallLog.find(c => c.endpoint === '/api/leaderboard/standings');
            if (leaderboardCall && leaderboardCall.response && leaderboardCall.response.data) {
                standings = leaderboardCall.response.data.standings || [];
            }
            totalTrades = this.apiResults.apiCallLog.filter(c => c.endpoint === '/api/negotiations/accept' && c.response.ok).length;
        }

        const validation = this.validateRoiCriteria(standings, totalTrades);

        console.log('Pass Criteria:');
        console.log(`   ‚Ä¢ Minimum positive ROI teams: ${this.config.minPositiveRoiTeams}`);
        console.log(`   ‚Ä¢ Minimum average ROI: ${this.config.minAverageRoi}%`);
        console.log(`   ‚Ä¢ Minimum total trades: ${this.config.minTotalTrades}`);
        console.log(`   ‚Ä¢ Maximum acceptable errors: ${this.config.maxAcceptableErrors}`);
        console.log('');

        if (standings.length > 0) {
            const positiveRoiCount = standings.filter(t => (t.roi || 0) > 0).length;
            const avgRoi = standings.reduce((sum, t) => sum + (t.roi || 0), 0) / standings.length;

            console.log('Actual Results:');
            console.log(`   ‚Ä¢ Teams with positive ROI: ${positiveRoiCount}/${standings.length} ${positiveRoiCount >= this.config.minPositiveRoiTeams ? '‚úÖ' : '‚ùå'}`);
            console.log(`   ‚Ä¢ Average ROI: ${avgRoi.toFixed(1)}% ${avgRoi >= this.config.minAverageRoi ? '‚úÖ' : '‚ùå'}`);
            console.log(`   ‚Ä¢ Total trades executed: ${totalTrades} ${totalTrades >= this.config.minTotalTrades ? '‚úÖ' : '‚ùå'}`);
            console.log(`   ‚Ä¢ Total errors: ${this.uiResults.errors.length + this.apiResults.errors.length} ${(this.uiResults.errors.length + this.apiResults.errors.length) <= this.config.maxAcceptableErrors ? '‚úÖ' : '‚ùå'}`);
        }

        console.log('='.repeat(80));

        // Overall verdict
        console.log('\nüéØ OVERALL VERDICT:');
        console.log('='.repeat(80));

        if (validation.passed) {
            console.log('‚úÖ PASSED - ROI criteria met!');
            console.log('   The game is functioning correctly with measurable economic activity.');
            if (validation.warnings.length > 0) {
                console.log('\nNon-critical warnings:');
                validation.warnings.forEach(w => console.log(`   ‚ö†Ô∏è  ${w}`));
            }
        } else {
            console.log('‚ùå FAILED - ROI criteria not met');
            console.log('\nCritical failures:');
            validation.failures.forEach(f => console.log(`   ‚ùå ${f}`));
            if (validation.warnings.length > 0) {
                console.log('\nAdditional warnings:');
                validation.warnings.forEach(w => console.log(`   ‚ö†Ô∏è  ${w}`));
            }
        }

        // Technical metrics (for info only)
        const goodCoverage = commonEndpoints.length >= apiEndpoints.size * 0.7;
        const apiSuccessRate = this.apiResults.successful / this.apiResults.apiCalls;

        console.log('\nTechnical Metrics (informational):');
        console.log(`   ‚Ä¢ API success rate: ${Math.round(apiSuccessRate * 100)}%`);
        console.log(`   ‚Ä¢ Endpoint coverage: ${Math.round((commonEndpoints.length / apiEndpoints.size) * 100)}%`);
        console.log(`   ‚Ä¢ UI/API consistency: ${goodCoverage ? 'Good' : 'Needs improvement'}`);

        console.log('='.repeat(80));
        console.log('');

        // Write comparison report to file
        const fs = require('fs');
        const report = {
            timestamp: new Date().toISOString(),
            passed: validation.passed,
            roiValidation: {
                passed: validation.passed,
                failures: validation.failures,
                warnings: validation.warnings,
                criteria: {
                    minPositiveRoiTeams: this.config.minPositiveRoiTeams,
                    minAverageRoi: this.config.minAverageRoi,
                    minTotalTrades: this.config.minTotalTrades,
                    maxAcceptableErrors: this.config.maxAcceptableErrors
                },
                actual: standings.length > 0 ? {
                    positiveRoiTeams: standings.filter(t => (t.roi || 0) > 0).length,
                    averageRoi: standings.reduce((sum, t) => sum + (t.roi || 0), 0) / standings.length,
                    totalTrades: totalTrades,
                    totalErrors: this.uiResults.errors.length + this.apiResults.errors.length,
                    standings: standings
                } : null
            },
            uiResults: this.uiResults,
            apiResults: this.apiResults,
            comparison: {
                commonEndpoints: commonEndpoints.length,
                apiOnlyEndpoints: apiOnlyEndpoints.length,
                uiEndpointsCovered: uiEndpoints.size,
                apiEndpointsTested: apiEndpoints.size,
                totalErrors: this.uiResults.errors.length + this.apiResults.errors.length,
                totalWarnings: this.uiResults.warnings.length + this.apiResults.warnings.length
            }
        };

        const reportFile = `dual-test-report-${Date.now()}.json`;
        fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
        console.log(`üìÑ Full comparison report written to: ${reportFile}\n`);
    }
}

// Run the dual test
if (require.main === module) {
    const test = new DualPlayabilityTest(CONFIG);
    test.run().catch(error => {
        console.error('Fatal error:', error);
        process.exit(1);
    });
}

module.exports = DualPlayabilityTest;
